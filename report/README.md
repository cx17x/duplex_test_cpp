# Тестовое задание C++ — Virtual Serial Protocol

## Описание задачи

Необходимо реализовать модель двустороннего канала связи между двумя устройствами:

* **Устройство A** — условный Raspberry Pi, отправляющий команды управления
* **Устройство B** — условный контроллер, принимающий команды и выполняющий их

Связь реализуется через виртуальный потокобезопасный канал и имитирует работу последовательного интерфейса.

---

## 1. Двусторонний канал связи

Реализован класс `VirtualSerial`, представляющий собой две независимые очереди сообщений:

* очередь сообщений **A → B**
* очередь сообщений **B → A**

Интерфейс класса:

```cpp
class VirtualSerial {
public:
    void sendAtoB(const std::vector<uint8_t>& data);
    void sendBtoA(const std::vector<uint8_t>& data);

    bool readA(std::vector<uint8_t>& out);
    bool readB(std::vector<uint8_t>& out);
};
```

### Требования

* потокобезопасность (`std::mutex` + `std::condition_variable`)
* методы `readA` / `readB` неблокирующие
* методы чтения возвращают `false`, если данных нет

---

## 2. Протокол управления

Обмен данными осуществляется бинарными пакетами фиксированной структуры.

### Формат пакета

| Поле        | Тип        | Описание               |
| ----------- | ---------- | ---------------------- |
| header      | `uint8_t`  | `0xAA`                 |
| version     | `uint8_t`  | версия протокола (`1`) |
| command_id  | `uint8_t`  | идентификатор команды  |
| payload_len | `uint8_t`  | количество байт данных |
| payload     | N bytes    | аргументы команды      |
| crc16       | `uint16_t` | CRC-16/X25             |

CRC рассчитывается **реально**, а не фиктивным XOR.

---

## 3. Команды (A → B)

### `0x10` — Установить PWM значение

Payload:

```cpp
uint16_t pwm_value;
```

---

### `0x20` — Установить PID коэффициенты

Payload:

```cpp
float kp;
float ki;
float kd;
```

---

### `0x30` — Запрос статуса

Payload отсутствует.

---

## 4. Ответы устройства B

Устройство B формирует и отправляет ответы в следующем формате:

| Command ID | Описание          | Payload                   |
| ---------- | ----------------- | ------------------------- |
| `0x81`     | подтверждение PWM | принятый `pwm_value`      |
| `0x82`     | подтверждение PID | `kp`, `ki`, `kd`          |
| `0x83`     | статус устройства | батарея %, температура C |

### Формирование статуса

Статус формируется случайным образом:

```cpp
battery = rand() % 100;
temperature = 20 + rand() % 30;
```

---

## 5. Многопоточность

В системе используется два потока.

### Поток 1 — Device A

* Каждые 100 мс отправляет одну из команд `0x10` или `0x30` (случайно)
* Получает ответы от устройства B
* Выводит полученные данные в `stdout`

Пример вывода:

```text
[A] Received ack: pwm=1234
[A] Received status: battery=87 temp=42
```

### Поток 2 — Device B

* Читает команды от устройства A
* Парсит и валидирует протокол
* Выполняет команду (симуляция)
* Отправляет ответ

---

## 6. Обязательные элементы

В проекте реализованы:

* сериализация и десериализация пакетов
* CRC-16/X25
* потокобезопасный виртуальный канал
* два потока-устройства
* логирование действий
* корректная обработка ошибок:

  * неверный CRC
  * неправильная длина пакета
  * неизвестная команда

---

## Требования к структуре проекта

```text
.
├── src
│   ├── virtual_serial.h
│   ├── virtual_serial.cpp
│   ├── protocol.h
│   ├── protocol.cpp
│   ├── device_a.h
│   ├── device_a.cpp
│   ├── device_b.h
│   ├── device_b.cpp
│   └── main.cpp
└── README.md
```

---

## Дополнительно (опционально)

* оформление протокола в виде класса
* RAII и умное управление ресурсами
* использование `std::span`
* использование `std::byte`
* юнит-тесты CRC
* thread-safe logging

---

## Отчёт о реализации

### Что сделано

1. **Виртуальный канал связи** — реализован класс `VirtualSerial`, предоставляющий потокобезопасные очереди для направлений A→B и B→A. Методы `send*` выполняют неблокирующую запись с уведомлением ожидающих потоков, `read*` выполняют неблокирующее чтение, а `waitRead*` позволяют блокироваться с таймаутом.
2. **Протокол** — описан в виде класса `protocol::Protocol`, отвечающего за сериализацию/десериализацию и вычисление CRC-16/X25. Структура `protocol::Packet` хранит распарсенные пакеты, а вспомогательные функции `appendPod`/`readPod` работают с POD-типами.
3. **Устройства A и B** — настроены как отдельные классы с методами `run`, которые запускаются в потоках. Device A генерирует команды (PWM, PID, запрос статуса) и обрабатывает ответы. Device B принимает команды, проверяет протокол, эмулирует действия и формирует ответы (ACK для PWM/PID и статус).
4. **Основной поток** — `main.cpp` создаёт общий канал, инициализирует устройства и запускает два рабочих потока. Через 5 секунд выполнение останавливается, потоки корректно завершаются.
5. **Структуризация кода** — исходники и заголовки перенесены в директорию `src/`, добавлен `report/README.md` с постановкой и отчётом, а корневой `README.md` указывает на полную документацию.

### Как реализованы ключевые части

#### VirtualSerial

- Две `std::deque<std::vector<uint8_t>>` хранят сообщения для каждого направления.
- Для каждой очереди есть свой `std::mutex` и `std::condition_variable`. Это исключает гонки между потоками устройств.
- `sendAtoB`/`sendBtoA` помещают копию пакета и делают `notify_one()`, чтобы разбудить ожидающий поток.
- `waitAndPop` реализует ожидание с таймаутом: поток блокируется на `condition_variable`, пока очередь пуста. Используется внутри `waitReadA/B`.
- `pop` предоставляет неблокирующий путь чтения, что позволяет дочитывать накопившиеся пакеты без повторного ожидания.

#### Protocol

- `Protocol::serialize` собирает пакет: заголовок, версию, ID, длину, payload и реальный CRC-16/X25. При ошибке (payload > 255 байт) бросается исключение.
- `Protocol::deserialize` проверяет минимальный размер, заголовок, версию, длину и CRC. В случае несоответствия возвращает `false` и пишет описание ошибки.
- CRC реализован по стандарту X25: отражение байта, прогон через полином `0x1021`, финальное отражение и XOR с `0xFFFF`.

#### Device A

- Использует `std::mt19937` для выбора команд и генерации PWM.
- При старте отправляет PID-команду (`sendPidCommand`), далее раз в 100 мс либо отправляет PWM (`sendPwmCommand`), либо запрашивает статус.
- Ответы читаются через `waitReadA` (короткий таймаут) и `readA`. `handleMessage` распознаёт ID ответов и печатает информацию (ACK PWM, ACK PID, Status).

#### Device B

- Циклически вызывает `processCommands`, который ожидает пакет через `waitReadB`.
- При получении пакета `handleCommand` проверяет ID и делегирует обработку конкретным методам.
- `handleSetPwm` и `handleSetPid` валидируют длину payload, выводят значения и отправляют подтверждения.
- `handleRequestStatus` генерирует случайную батарею/температуру и отправляет статус.

#### Основной поток

- Создаёт `VirtualSerial channel`, затем `DeviceA` и `DeviceB`, которым передаётся ссылка на канал.
- Запускает два `std::thread`, каждый вызывает `run` соответствующего устройства.
- Через 5 секунд выставляет `running = false`, ждёт завершения потоков и выводит “Simulation finished.”

### Проверка

Сборка и запуск:

```bash
g++ -std=c++17 src/*.cpp -pthread -o virtual_serial
./virtual_serial
```

При запуске в консоль выводятся логи устройств A и B, демонстрирующие успешный обмен командами и ответами.
