# Тестовое задание C++ — Virtual Serial Protocol

## Описание задачи

Необходимо реализовать модель двустороннего канала связи между двумя устройствами:

* **Устройство A** — условный Raspberry Pi, отправляющий команды управления
* **Устройство B** — условный контроллер, принимающий команды и выполняющий их

Связь реализуется через виртуальный потокобезопасный канал и имитирует работу последовательного интерфейса.

---

## 1. Двусторонний канал связи

Реализован класс `VirtualSerial`, представляющий собой две независимые очереди сообщений:

* очередь сообщений **A → B**
* очередь сообщений **B → A**

Интерфейс класса:

```cpp
class VirtualSerial {
public:
    void sendAtoB(const std::vector<uint8_t>& data);
    void sendBtoA(const std::vector<uint8_t>& data);

    bool readA(std::vector<uint8_t>& out);
    bool readB(std::vector<uint8_t>& out);
};
```

### Требования

* потокобезопасность (`std::mutex` + `std::condition_variable`)
* методы `readA` / `readB` неблокирующие
* методы чтения возвращают `false`, если данных нет

---

## 2. Протокол управления

Обмен данными осуществляется бинарными пакетами фиксированной структуры.

### Формат пакета

| Поле        | Тип        | Описание               |
| ----------- | ---------- | ---------------------- |
| header      | `uint8_t`  | `0xAA`                 |
| version     | `uint8_t`  | версия протокола (`1`) |
| command_id  | `uint8_t`  | идентификатор команды  |
| payload_len | `uint8_t`  | количество байт данных |
| payload     | N bytes    | аргументы команды      |
| crc16       | `uint16_t` | CRC-16/X25             |

CRC рассчитывается **реально**, а не фиктивным XOR.

---

## 3. Команды (A → B)

### `0x10` — Установить PWM значение

Payload:

```cpp
uint16_t pwm_value;
```

---

### `0x20` — Установить PID коэффициенты

Payload:

```cpp
float kp;
float ki;
float kd;
```

---

### `0x30` — Запрос статуса

Payload отсутствует.

---

## 4. Ответы устройства B

Устройство B формирует и отправляет ответы в следующем формате:

| Command ID | Описание          | Payload                   |
| ---------- | ----------------- | ------------------------- |
| `0x81`     | подтверждение PWM | принятый `pwm_value`      |
| `0x82`     | подтверждение PID | `kp`, `ki`, `kd`          |
| `0x83`     | статус устройства | батарея %, температура C |

### Формирование статуса

Статус формируется случайным образом:

```cpp
battery = rand() % 100;
temperature = 20 + rand() % 30;
```

---

## 5. Многопоточность

В системе используется два потока.

### Поток 1 — Device A

* Каждые 100 мс отправляет одну из команд `0x10` или `0x30` (случайно)
* Получает ответы от устройства B
* Выводит полученные данные в `stdout`

Пример вывода:

```text
[A] Received ack: pwm=1234
[A] Received status: battery=87 temp=42
```

### Поток 2 — Device B

* Читает команды от устройства A
* Парсит и валидирует протокол
* Выполняет команду (симуляция)
* Отправляет ответ

---

## 6. Обязательные элементы

В проекте реализованы:

* сериализация и десериализация пакетов
* CRC-16/X25
* потокобезопасный виртуальный канал
* два потока-устройства
* логирование действий
* корректная обработка ошибок:

  * неверный CRC
  * неправильная длина пакета
  * неизвестная команда

---

## Требования к структуре проекта

```text
.
├── virtual_serial.h
├── virtual_serial.cpp
├── protocol.h
├── protocol.cpp
├── device_a.h
├── device_a.cpp
├── device_b.h
├── device_b.cpp
├── main.cpp
└── README.md
```

---

## Дополнительно (опционально)

* оформление протокола в виде класса
* RAII и умное управление ресурсами
* использование `std::span`
* использование `std::byte`
* юнит-тесты CRC
* thread-safe logging

---

## Сборка и запуск

```bash
g++ -std=c++17 *.cpp -pthread -o virtual_serial
./virtual_serial
```

---

## Результат выполнения задания

Результат выполнения задания представлен в виде публичного GitHub-репозитория, доступного для просмотра.
